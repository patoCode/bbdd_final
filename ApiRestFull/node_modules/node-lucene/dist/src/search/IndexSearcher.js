"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_java_rt_1 = require("node-java-rt");
const getLuceneJava_1 = require("../util/getLuceneJava");
const TopDocs_1 = __importDefault(require("./TopDocs"));
const Document_1 = __importDefault(require("../document/Document"));
/**
 * Implements search over a single IndexReader. Applications usually need only call the inherited
 * search(Query,int) method. For performance reasons, if your index is unchanging, you should share a single
 * IndexSearcher instance across multiple searches instead of creating a new one per-search. If your index has
 * changed and you wish to see the changes reflected in searching, you should use
 * DirectoryReader.openIfChanged(DirectoryReader) to obtain a new reader and then create a new IndexSearcher
 * from that. Also, for low-latency turnaround it's best to use a near-real-time reader
 * (DirectoryReader.open(IndexWriter)). Once you have a new IndexReader, it's relatively cheap to create a new
 * IndexSearcher from it.
 *
 * NOTE: IndexSearcher instances are completely thread safe, meaning multiple threads can call any of its
 * methods, concurrently. If your application requires external synchronization, you should not synchronize on
 * the IndexSearcher instance; use your own (non-Lucene) objects instead.
 */
class IndexSearcher extends node_java_rt_1.lang.Object {
    /** Creates a searcher searching the provided index. */
    constructor(r) {
        super();
        this._java = getLuceneJava_1.getLuceneJava().newInstanceSync(IndexSearcher._javaClassName(), r._java);
    }
    static _javaClassName() {
        return 'org.apache.lucene.search.IndexSearcher';
    }
    /** Finds the top n hits for query. */
    searchSync(query, n) {
        return IndexSearcher._buildSync(this._java.searchSync(query._java, n), new TopDocs_1.default());
    }
    /** Finds the top n hits for query. */
    search(query, n) {
        return this.searchSync.apply(this, arguments);
    }
    /** Finds the top n hits for query. */
    searchPromise(query, n) {
        return IndexSearcher._buildPromise(this._java.searchPromise(query._java, n), new TopDocs_1.default());
    }
    docSync(docId) {
        return IndexSearcher._buildSync(this._java.docSync(docId), new Document_1.default());
    }
    doc(docId) {
        return IndexSearcher._buildSync(this._java.docSync(docId), new Document_1.default());
    }
    docPromise(docId) {
        return IndexSearcher._buildPromise(this._java.docPromise(docId), new Document_1.default());
    }
}
exports.default = IndexSearcher;
//# sourceMappingURL=IndexSearcher.js.map